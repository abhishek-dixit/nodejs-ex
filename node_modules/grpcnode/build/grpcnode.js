#!/usr/bin/env node
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _fs = require('fs');

var _path = require('path');

var _yargs = require('yargs');

var _yargs2 = _interopRequireDefault(_yargs);

var _lodash = require('lodash');

var _grpc = require('grpc');

var _grpc2 = _interopRequireDefault(_grpc);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _indent = require('indent');

var _indent2 = _interopRequireDefault(_indent);

var _jsoncolor = require('jsoncolor');

var _jsoncolor2 = _interopRequireDefault(_jsoncolor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// require, but find the file from where the user is
var reqCwd = function reqCwd(name) {
  return require((0, _path.resolve)(process.cwd(), name));
};

// synchronous read file, from where user is
var readFile = function readFile(name) {
  return (0, _fs.readFileSync)((0, _path.resolve)(process.cwd(), name));
};

// show an error and exit
var error = function error(msg) {
  _yargs2.default // eslint-disable-line
  .showHelp();
  console.error(_chalk2.default.red(msg));
  process.exit(1);
};

// regex used to split up command for client run
var rCommand = /^(.+)\((.*)\)$/;

// get credentials for SSL or not
var getCredentials = function getCredentials(ca, key, cert) {
  var server = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  var credentials = void 0;
  var factory = server ? _grpc2.default.ServerCredentials : _grpc2.default.credentials;
  if (ca || key || cert) {
    if (!(ca && key && cert)) {
      error('SSL requires --ca, --key, & --cert\n');
    }
    credentials = factory.createSsl(readFile(ca), [{
      cert_chain: readFile(cert),
      private_key: readFile(key)
    }], true);
  } else {
    credentials = factory.createInsecure();
  }
  return credentials;
};

// recursive inner-loop for makeServer
var addImplementations = function addImplementations(proto, server, implementation) {
  var name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  var debug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  var handlers = {};
  Object.keys(implementation).forEach(function (i) {
    if (typeof implementation[i] === 'function') {
      var formattedName = _chalk2.default.blue(name.replace(/^\./, _chalk2.default.white('/')).replace(/\./g, _chalk2.default.white('.')) + '/' + _chalk2.default.cyan(i));
      if (debug) {
        console.log(formattedName + ' added.');
      }
      handlers[i] = function (ctx, cb) {
        Promise.resolve(implementation[i](ctx)).then(function (res) {
          if (debug) {
            console.log('GRPC: ' + _chalk2.default.yellow(new Date().toISOString()) + ' (' + _chalk2.default.cyan(ctx.getPeer()) + '): ' + formattedName + '(' + (0, _jsoncolor2.default)(ctx.request) + ')');
          }
          if (cb) {
            cb(null, res);
          }
        }).catch(function (err) {
          if (debug) {
            console.error(_chalk2.default.red('ERROR'), err.message);
          }
          if (cb) {
            cb(err);
          } else {
            ctx.emit('error', err);
          }
        });
      };
    } else {
      addImplementations(proto[i], server, implementation[i], name + '.' + i, debug);
    }
  });
  if (proto.service) {
    server.addService(proto.service, handlers);
  }
};

// given an implementation object and some proto-filenames, make a server
var makeServer = function makeServer(implementation, protoFiles, root, quiet) {
  var server = new _grpc2.default.Server();
  protoFiles.forEach(function (file) {
    var proto = _grpc2.default.load({ file: file, root: root });
    addImplementations(proto, server, implementation, '', !quiet);
  });
  return server;
};

// display structure of proto service
var ls = function ls(proto) {
  Object.keys(proto).forEach(function (p) {
    if (_typeof(proto[p]) === 'object') {
      ls(proto[p]);
    }
    if (proto[p].service) {
      console.log(Object.values(proto[p].service).map(function (p) {
        return p.path.replace(/\/(.+)\/[0-9a-zA-Z_]+$/, '/' + _chalk2.default.yellow('$1') + '/' + _chalk2.default.green(p.originalName) + ('(' + _chalk2.default.cyan(p.requestType.name) + ') => ' + _chalk2.default.cyan(p.responseType.name))) + '\n' + (0, _indent2.default)(_chalk2.default.cyan(p.requestType.name) + ': ' + (0, _jsoncolor2.default)(p.requestDeserialize(p.requestSerialize({}))), 2) + '\n' + (0, _indent2.default)(_chalk2.default.cyan(p.responseType.name) + ': ' + (0, _jsoncolor2.default)(p.responseDeserialize(p.responseSerialize({}))), 2);
      }).join('\n\n'));
    }
  });
};

// run a remote gRPC command
var run = function run(files, rpc, input) {
  var host = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'localhost:50051';
  var root = arguments[4];
  var ca = arguments[5];
  var key = arguments[6];
  var cert = arguments[7];

  var credentials = getCredentials(ca, key, cert, false);
  var hold = false;

  var _loop = function _loop(f) {
    var proto = _grpc2.default.load({ file: files[f], root: root });
    var ns = rpc.split('/')[1];
    var Service = (0, _lodash.get)(proto, ns);
    if (Service) {
      var client = new Service(host, credentials);
      var mname = Object.keys(Service.service).filter(function (s) {
        return Service.service[s].path === rpc;
      }).pop();
      if (mname) {
        // TODO: process.stdin for streaming input
        if (client[mname].responseStream) {
          var call = client[mname](input);
          call.on('data', function (d) {
            return console.log((0, _jsoncolor2.default)(d));
          });
          hold = true;
          return {
            v: Promise.resolve('')
          };
        } else {
          return {
            v: new Promise(function (resolve, reject) {
              client[mname](input, function (err, res) {
                if (err) return reject(err);
                return resolve(res);
              });
            })
          };
        }
      }
    }
  };

  for (var f in files) {
    var _ret = _loop(f);

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }
  if (!hold) {
    return Promise.reject(new Error('Method not found.'));
  }
};

_yargs2.default.command('server <FILES...>', 'Start a gRPC server with your proto and javascript files', function (yargs) {
  yargs.boolean('quiet').describe('quiet', 'Suppress logs').alias('quiet', 'q').example('$0 server -I example/proto helloworld.proto example/helloworld.js', 'Start a gRPC server');
}, function (argv) {
  var files = Array.isArray(argv.FILES) ? argv.FILES : [argv.FILES];
  var protoFiles = files.filter(function (n) {
    return (0, _path.extname)(n) === '.proto';
  });
  var jsFiles = files.filter(function (n) {
    return (0, _path.extname)(n) === '.js';
  }).map(function (n) {
    return reqCwd(n);
  });
  if (!protoFiles.length) {
    error('You must set at least 1 proto IDL file.');
  }
  if (!jsFiles.length) {
    error('You must set at least 1 js implementation file.');
  }
  var ca = argv.ca,
      key = argv.key,
      cert = argv.cert,
      host = argv.host,
      include = argv.include,
      quiet = argv.quiet;

  var implementation = _lodash.merge.apply(undefined, [{}].concat(_toConsumableArray(jsFiles)));
  var credentials = getCredentials(ca, key, cert);
  var server = makeServer(implementation, protoFiles, (0, _path.resolve)(process.cwd(), include), quiet);
  server.bind(host, credentials);
  if (!quiet) {
    console.log(_chalk2.default.yellow('gRPC protobuf server started on ' + _chalk2.default.green(host) + (ca ? _chalk2.default.blue(' using SSL') : '')));
  }
  server.start();
}).command('client <command> <FILES...>', 'Act as a client of a gRPC server', function (yargs) {
  yargs.command('ls <FILES...>', 'List available services on the gRPC server', function (yargs) {
    yargs.example('$0 client ls -I example/proto helloworld.proto', 'Get a list of available gRPCs');
  }, function (argv) {
    var files = Array.isArray(argv.FILES) ? argv.FILES : [argv.FILES];
    var protoFiles = files.filter(function (n) {
      return (0, _path.extname)(n) === '.proto';
    });
    if (!protoFiles.length) {
      error('You must set at least 1 proto IDL file.');
    }
    files.forEach(function (file) {
      var proto = _grpc2.default.load({ file: file, root: argv.include });
      ls(proto);
    });
  }).command('run <FILES...>', 'Call an RPC on the gRPC server', function (yargs) {
    yargs.describe('command', '[REQUIRED] The command you want to run').alias('command', 'c').example('$0 client run -I example/proto helloworld.proto -c \'/helloworld.v1.Greeter/SayHello({"name": "David"})\'', 'Call gRPC with a parameter. Parameter should be JSON.').example('$0 client run -I example/proto helloworld.proto -c \'/helloworld.v1.Greeter/SayHello()\'', 'Call gRPC with no parameter.');
  }, function (argv) {
    var ca = argv.ca,
        key = argv.key,
        cert = argv.cert,
        host = argv.host,
        include = argv.include,
        command = argv.command,
        FILES = argv.FILES;

    if (!command) {
      error('Command is required.');
    }
    try {
      var input = {};

      var _rCommand$exec = rCommand.exec(command),
          _rCommand$exec2 = _slicedToArray(_rCommand$exec, 3),
          _ = _rCommand$exec2[0],
          rpc = _rCommand$exec2[1],
          param = _rCommand$exec2[2]; // eslint-disable-line


      if (param !== '') {
        input = JSON.parse(param);
      }
      run(FILES, rpc, input, host, (0, _path.resolve)(process.cwd(), include), ca, key, cert).then(function (r) {
        console.log((0, _jsoncolor2.default)(r));
      }).catch(function (e) {
        console.error(_chalk2.default.red(e));
        process.exit(1);
      });
    } catch (e) {
      console.error(_chalk2.default.red(e.message));
      console.error(e);
      error('Please check the format of your gRPC call');
    }
  }).demandCommand(1, 'You must set a command: `ls` or `run`');
}).example('$0 client --help', 'Get more help about the client command').example('$0 server --help', 'Get more help about the server command').help().version().alias('v', 'version').wrap(process.stdout.columns).demandCommand(1, 'You must set a command: `server` or `client`').describe('include', 'Root include path (sorry only one root-path works)').alias('I', 'include').describe('ca', 'SSL CA cert').describe('key', 'SSL server key').describe('cert', 'SSL server certificate').describe('h', 'The host/port to run the gRPC server on').default('h', process.env.GRPC_HOST || 'localhost:50051').alias('h', 'host').argv;